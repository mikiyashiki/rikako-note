# 垃圾回收器
* ## 垃圾回收器分类：
  * 串行垃圾回收器：
    * 单线程情况下使用
  * 吞吐量优先的垃圾回收器：
    * 适合在多线程情况下使用
    * 其会让单位时间内STW时间之和尽可能变短
  * 响应时间优先的垃圾回收器：
    * 同样适用于多核cpu情况
    * 其会尽可能让单次垃圾回的STW时间变短
* ## 串行垃圾回收器：
  * 开启串行垃圾回收器：
  ```java
    // 可以通过指定JVM参数来指定使用串行垃圾回收器
    // 其会使用Serial和Serial Old来作为垃圾回收器
    //      Serial：年轻代垃圾回收器（使用复制算法）
    //      Serial Old：老年代垃圾回收器（使用标记整理算法）
    -XX：+UseSerialGC
  ```
  * 串行垃圾回收器的回收流程：
    * 串行垃圾回收器只有一个垃圾回收的线程，当垃圾回收线程进行垃圾回收时，会暂停所有的用户线程，直到垃圾回收完成后用户线程才继续运行
* ## 吞吐量优先的垃圾回收器：
  * 开启吞吐量优先的垃圾回收器：
  ```java
  // 指定JVM参数-XX:+UseParallelGC可以开启吞吐量优先的垃圾回收器
  // 其是JDK1.8环境下的默认垃圾回收器
  // 其会允许多个垃圾回收线程并行的执行垃圾回收工作
  -XX：+UseParallelGC
  ```
* ## 响应时间优先的垃圾回收器：
  * 响应时间优先的垃圾回收器采用cms垃圾回收其作为老年代垃圾回收器，而使用ParNewGC作为新生代垃圾回收器
  ```java
  -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
  ```
  * CMS垃圾回收工作流程：
    * 初始标记：此时需要STW，用户线程会暂停
    * 并发标记：并发标记时用户线程不需要暂停
    * 再标记：再标记时用户线程需要暂停，会产生STW
    * 并发清除：此阶段用户线程不会暂停，不需要STW
  * CMS垃圾回收缺点：
    * 在CMS进行并发清除时，并没有STW，其他用户线程在运行时可能会产生垃圾。产生的垃圾在这次垃圾回收时无法被回收，会留给下一次垃圾回收时进行清理。留给下一次垃圾回收进行清理的垃圾称之为浮动垃圾。、
    * CMS垃圾回收器采用的是标记清除算法，在长时间运行后可能会产生内存碎片。在产生内存碎片过多后，CMS会退化为Serial Old垃圾回收器并通过标记整理算法来避免内存碎片过多的情况

* ## G1垃圾回收器
  * G1垃圾回收器特性：
    * G1垃圾回收器同时注重了低延时和吞吐量
    * G1垃圾回收器适合与超大堆内存的管理
    * G1垃圾回收器会将对内存划分为多个大小相等的Region，每个Region可以独立作为Eden区、Surivor区或老年代区域
    * G1垃圾回收气整体上采用的是标记整理算法，但是两个Region之间采用的是复制算法
  * G1垃圾回收器的开启操作：
  ```java
  // 通过指定JVM参数开启G1垃圾回收器
  -XX:+UseG1GC
  ```